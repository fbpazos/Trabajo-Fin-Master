\section*{NonLinear}
\subsection*{Bisection* Method}
\begin{algorithm}[H]
\SetAlgoLined
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \SetKwProg{Fn}{Function}{}{}
\Input{Function $f$, interval $[a,b]$, number of maximum iterations $stop\_iters$, argument list $*args$}
\Output{Approximate zero of $f$}
\Fn{bisect($fun, interval, stop\_iters, iters, *args$)}{
  $x_0, x_1 \gets a, b$ \;
  $f_0, f_1 \gets f(x_0,*args), f(x_1,*args)$ \;
  \If{$f_0 \times f_1 > 0$}{
    \textbf{raise} ValueError("No zeros in the given interval") \;
  }
  $x \gets x_1$ \;
  $iterations \gets 0$ \;
  \While{$f_1 \neq 0$ \textbf{and} $iterations < stop\_iters$}{
    $iterations \gets iterations + 1$ \;
    $x \gets 0.5 \cdot (x_0 + x_1)$ \;
    $f \gets f(x, *args)$ \;
    \If{$f \times f_1 < 0$}{
      $x_0 \gets x$ \;
    } \Else{
      $x_1 \gets x$ \;
      $f_1 \gets f$ \;
    }
  }
  \If{iters}{
    \KwRet{$x, iterations$} \;
  }
  \KwRet{$x$} \;
  }
  \caption{Bisection* Method}
\end{algorithm}
\subsubsection*{BNumMet Examples}
\input{Content/Thesis/Documentation/Examples/NonLinear/Bisection Examples}



\subsection*{Secant Method}
\begin{algorithm}[H]
\SetAlgoLined
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \SetKwProg{Fn}{Function}{}{}
\Input{Function $f$, interval $[a,b]$, number of maximum iterations $stop\_iters$, argument list $*args$}
\Output{Approximate zero of $f$}
\Fn{secant($fun, interval, stop\_iters, iters, *args$)}{initialization: x0, x1 = interval\;
 f0 = fun(x0, *args)\;
 f1 = fun(x1, *args)\;
 \eIf{f0 * f1 > 0}{
  raise ValueError("The function has no zeros in the given interval")\;
  }{
   iterations = 0\;
   \While{abs(x1 - x0) > $\epsilon$ and iterations < stop\_iters}{
    iterations += 1\;
    x2 = x0\;
    x0 = x1\;
    x1 = x1 + (x1 - x2) / (fun(x2, *args) / fun(x1, *args) - 1)\;
   }
   \eIf{iters}{
    return x1, iterations\;
    }{
    return x1\;
   }
  }}
 \caption{Secant Method}
\end{algorithm}
\subsubsection*{BNumMet Examples}
\input{Content/Thesis/Documentation/Examples/NonLinear/Secant Examples}

\subsection*{Newton's Method}
\begin{algorithm}[H]
\SetAlgoLined
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \SetKwProg{Fn}{Function}{}{}
\Input{fun, derivative, start\_point, stop\_iters=100, iters=False, *args}
\Output{x: zeros of the function fun}
\Fn{newton($fun, derivative, start\_point, stop\_iters, iters, *args$)}
{ 
initialization: previous\_x = start\_point - 1\;
 xn = start\_point\;
 fn = fun(xn, *args)\;
 \eIf{derivative(xn, *args) == 0}{
  raise ValueError("The derivative of the function is zero")\;
  }{
   iterations = 0\;
   \While{fn != 0 and not np.isclose(xn - previous\_x, 0) and derivative(xn, *args) != 0 and iterations < stop\_iters}{
    iterations += 1\;
    previous\_x = xn\;
    xn = xn - fn / derivative(xn, *args)\;
    fn = fun(xn, *args)\;
   }
   \eIf{iters}{
    return xn, iterations\;
    }{
    return xn\;
   }
  }}
 \caption{Newton-Raphson Method}
\end{algorithm}
\subsubsection*{BNumMet Examples}
\input{Content/Thesis/Documentation/Examples/NonLinear/Newtons Examples}


\subsection*{Inverse Quadratic Interpolation (I.Q.I.)}
\begin{algorithm}[H]
\SetAlgoLined
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \SetKwProg{Fn}{Function}{}{}

    \Input{Function $f$, Initial values of $x_0$, $x_1$, $x_2$, Maximum number of iterations $stop\_iters$, and Optional arguments $args$}
    \Output{Zeros of the function $f$}
    \Fn{IQI($f, x\_values, stop\_iters, iters, *args$)}{
        $x_0, x_1, x_2 \leftarrow x\_values$\;
        $iterations \leftarrow 0$\;
        \While{$\left| x_1 - x_0 \right| > \epsilon$ and $iterations < stop\_iters$}{
            $f_0, f_1, f_2 \leftarrow f(x_0, *args), f(x_1, *args), f(x_2, *args)$\;
            $aux1 \leftarrow \frac{x_0 f_1 f_2}{(f_0 - f_1)(f_0 - f_2)}$\;
            $aux2 \leftarrow \frac{x_1 f_0 f_2}{(f_1 - f_0)(f_1 - f_2)}$\;
            $aux3 \leftarrow \frac{x_2 f_1 f_0}{(f_2 - f_0)(f_2 - f_1)}$\;
            $new \leftarrow aux1 + aux2 + aux3$\;
            $x_0, x_1, x_2 \leftarrow new, x_0, x_1$\;
            $iterations \leftarrow iterations + 1$\;
        }
        \If{iters}{
            \Return $x_0$, $iterations$\;
        }
        \Return $x_0$\;
    }
     \caption{Inverse Quadratic Interpolation}
\end{algorithm}
\subsubsection*{BNumMet Examples}
\input{Content/Thesis/Documentation/Examples/NonLinear/IQI Examples}

\subsection*{Brentt-Dekker}
Multiple implementations with small differences exist, we opted for the original one publish by Brent \cite{brent2002algorithms}, the reason behind the naming of Brent-Dekker Algorithm is because at first Dekker in conjunction with Wingartenn and their respective colleagues proposed an initial version, later Brent came an offer a better approach and convergence \cite{Press2007}, in some references like Scipy's they will call this algorithm Brent-Wingartenn-Dekker Algorithm.


\begin{algorithm}[H] 
\DontPrintSemicolon 
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output} 
\SetKwProg{Fn}{Function}{}{}
\SetKwFunction{FBrentDekker}{zBrentDekker} 
\SetKw{KwRaise}{Raise}

\Input{Function $f$, interval $[a,b]$, tolerance $tol$, maximum iterations $stop_iters$, arguments $\ast args$} 
\Output{Zero of $f$ in $[a,b]$} 

\Fn{zBrentDekker($f, interval, tol, stop\_iters, iters, steps, *args$)}{
$fa \gets f(a, *args)$; $fb \gets f(b, *args)$;\\
\lIf{$fa * fb > 0$}{\KwRaise{Error(“Function has no zeros in the given interval”)}}

$c \gets a$; $fc \gets fa$;
$d \gets b - a$;
$e \gets b - a$; \\

\lIf{$abs(fc) < abs(fb)$}{ 
    $a, b, c \gets b, c, b$;
    $fa, fb, fc \gets fb, fc, fb$; 
} 
$tolerance \gets 2 * \epsilon * abs(b) + tol$; \\
$m \gets 0.5 * (c - b)$; $iterations \gets 0$; \\

\While{$abs(m) > tolerance$ \textbf{and} $fb$ \textbf{and} $iterations < stop\_iters$}{ 
\lIf{$abs(e) < tolerance$ \textbf{or} $abs(fa) <= abs(fb)$}{ 
    $d \gets m$; $\bigwedge$
    $e \gets m$; 
} 
\Else{ 
    $s \gets fb / fa$; \\
    \lIf{$a == c$}{ 
        $p \gets 2 * m * s$; $\bigwedge$
        $q \gets 1 - s$; 
    } 
    
    \Else{ 
        $q \gets fa / fc$; $r \gets fb / fc$; \\
        $p \gets s * (2 * m * q * (q - r) - (b - a) * (r - 1))$; \\
        $q \gets (q - 1) * (r - 1) * (s - 1)$; } 
        
    \lIf{$p > 0$}{ $q \gets -q$;} 
    \lElse{$p \gets -p$;} 
    
    $s \gets e$; $\bigwedge$ $e \gets d$; 
    
    \lIf{$2p < 3m\cdot q - |tolerance * q|$ and $p < abs(0.5\cdot s\cdot q)$}{ 
        $d \gets p / q$; 
       } 
    \lElse{ $d \gets m$; $e \gets m$; } 
} 

$a \gets b$; $\bigwedge$ $fa \gets fb$;\\ 
$b \gets b + d$ \textbf{if} $abs(d) > tolerance$ \textbf{else} $b + np.sign(m) * tolerance$; \\
$fb \gets f(b, *args)$; \\
\lIf{$np.sign(fb) == np.sign(fc)$}{ 
    $c, fc, d, e \gets a, fa, b - a, b - a$ 
} 
\lElseIf{$abs(fc) < abs(fb)$}{ 
    $a, b, c \gets b, c, b$; $fa, fb, fc \gets fb, fc, fb$ 
} 
$tolerance \gets 2 * \epsilon * abs(b) + tol$; \\
$m \gets 0.5 * (c - b)$; $iterations \gets iterations + 1$ 
} 
$zero \gets b$\\
\Return $zero$\;}


\caption{Brent-Dekker's Algorithm}

\label{algo:zBrentDekker} 
\end{algorithm}
\subsubsection*{BNumMet Examples}
\input{Content/Thesis/Documentation/Examples/NonLinear/Brent Dekker Examples}